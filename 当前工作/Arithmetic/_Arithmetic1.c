
모모static const uint8 nand_ecc_precalc_table[] =
모모{
모모모모0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
모모모모0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
모모모모0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
모모모모0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
모모모모0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
모모모모0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
모모모모0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
모모모모0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
모모모모0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
모모모모0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
모모모모0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
모모모모0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
모모모모0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
모모모모0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
모모모모0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
모모모모0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
모모};

모모//모Creates non-inverted ECC code from line parity
모모static void nand_trans_result(u_char reg2, u_char reg3,u_char *ecc_code)
모모{
모모모모u_char a, b, i, tmp1, tmp2;

모모모모/* Initialize variables */
모모모모a = b = 0x80;
모모모모tmp1 = tmp2 = 0;

모모모모/* Calculate first ECC byte */
모모모모for (i = 0; i < 4; i++)
모모모모{
모모모모모모if (reg3 & a)모모모 /* LP15,13,11,9 --> ecc_code[0] */
모모모모모모모모tmp1 |= b;
모모모모모모b >>= 1;
모모모모모모if (reg2 & a)모모모 /* LP14,12,10,8 --> ecc_code[0] */
모모모모모모모모tmp1 |= b;
모모모모모모b >>= 1;
모모모모모모a >>= 1;
모모모모}

모모모모/* Calculate second ECC byte */
모모모모b = 0x80;
모모모모for (i = 0; i < 4; i++)
모모모모{
모모모모모모if (reg3 & a)모모모 /* LP7,5,3,1 --> ecc_code[1] */
모모모모모모모모tmp2 |= b;
모모모모모모b >>= 1;
모모모모모모if (reg2 & a)모모모 /* LP6,4,2,0 --> ecc_code[1] */
모모모모모모모모tmp2 |= b;
모모모모모모b >>= 1;
모모모모모모a >>= 1;
모모모모}

모모모모/* Store two of the ECC bytes */
모모모모ecc_code[0] = tmp1;
모모모모ecc_code[1] = tmp2;
모모}

모모//모Calculate 3 byte ECC code for 256 byte block
모모void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
모모{
모모모모u_char idx, reg1, reg2, reg3;
모모모모int j;

모모모모/* Initialize variables */
모모모모reg1 = reg2 = reg3 = 0;
모모모모ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

모모모모/* Build up column parity */
모모모모for(j = 0; j < 256; j++)
모모모모{

모모모모모모/* Get CP0 - CP5 from table */
모모모모모모idx = nand_ecc_precalc_table[dat[j]];
모모모모모모reg1 ^= (idx & 0x3f);

모모모모모모/* All bit XOR = 1 ? */
모모모모모모if (idx & 0x40) {
모모모모모모모모reg3 ^= (u_char) j;
모모모모모모모모reg2 ^= ~((u_char) j);
모모모모모모}
모모모모}

모모모모/* Create non-inverted ECC code from line parity */
모모모모nand_trans_result(reg2, reg3, ecc_code);

모모모모/* Calculate final ECC code */
모모모모ecc_code[0] = ~ecc_code[0];
모모모모ecc_code[1] = ~ecc_code[1];
모모모모ecc_code[2] = ((~reg1) << 2) | 0x03;
모모}

모모//모Detect and correct a 1 bit error for 256 byte block
모모int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
모모{
모모모모u_char a, b, c, d1, d2, d3, add, bit, i;

모모모모/* Do error detection */
모모모모d1 = calc_ecc[0] ^ read_ecc[0];
모모모모d2 = calc_ecc[1] ^ read_ecc[1];
모모모모d3 = calc_ecc[2] ^ read_ecc[2];

모모모모if ((d1 | d2 | d3) == 0)
모모모모{
모모모모모모/* No errors */
모모모모모모return 0;
모모모모}
모모모모else
모모모모{
모모모모모모a = (d1 ^ (d1 >> 1)) & 0x55;
모모모모모모b = (d2 ^ (d2 >> 1)) & 0x55;
모모모모모모c = (d3 ^ (d3 >> 1)) & 0x54;

모모모모모모/* Found and will correct single bit error in the data */
모모모모모모if ((a == 0x55) && (b == 0x55) && (c == 0x54))
모모모모모모{
모모모모모모모모c = 0x80;
모모모모모모모모add = 0;
모모모모모모모모a = 0x80;
모모모모모모모모for (i=0; i<4; i++)
모모모모모모모모{
모모모모모모모모모모if (d1 & c)
모모모모모모모모모모모모add |= a;
모모모모모모모모모모c >>= 2;
모모모모모모모모모모a >>= 1;
모모모모모모모모}
모모모모모모모모c = 0x80;
모모모모모모모모for (i=0; i<4; i++)
모모모모모모모모{
모모모모모모모모모모if (d2 & c)
모모모모모모모모모모모모add |= a;
모모모모모모모모모모c >>= 2;
모모모모모모모모모모a >>= 1;
모모모모모모모모}
모모모모모모모모bit = 0;
모모모모모모모모b = 0x04;
모모모모모모모모c = 0x80;
모모모모모모모모for (i=0; i<3; i++)
모모모모모모모모{
모모모모모모모모모모if (d3 & c)
모모모모모모모모모모모모bit |= b;
모모모모모모모모모모c >>= 2;
모모모모모모모모모모b >>= 1;
모모모모모모모모}
모모모모모모모모b = 0x01;
모모모모모모모모a = dat[add];
모모모모모모모모a ^= (b << bit);
모모모모모모모모dat[add] = a;
모모모모모모모모return 1;
모모모모모모}
모모모모모모else
모모모모모모{
모모모모모모모모i = 0;
모모모모모모모모while (d1)
모모모모모모모모{
모모모모모모모모모모if (d1 & 0x01)
모모모모모모모모모모모모++i;
모모모모모모모모모모d1 >>= 1;
모모모모모모모모}
모모모모모모모모while (d2)
모모모모모모모모{
모모모모모모모모모모if (d2 & 0x01)
모모모모모모모모모모모모++i;
모모모모모모모모모모d2 >>= 1;
모모모모모모모모}
모모모모모모모모while (d3)
모모모모모모모모{
모모모모모모모모모모if (d3 & 0x01)
모모모모모모모모모모모모++i;
모모모모모모모모모모d3 >>= 1;
모모모모모모모모}
모모모모모모모모if (i == 1)
모모모모모모모모{
모모모모모모모모모모/* ECC Code Error Correction */
모모모모모모모모모모read_ecc[0] = calc_ecc[0];
모모모모모모모모모모read_ecc[1] = calc_ecc[1];
모모모모모모모모모모read_ecc[2] = calc_ecc[2];
모모모모모모모모모모return 2;
모모모모모모모모}
모모모모모모모모else
모모모모모모모모{
모모모모모모모모모모/* Uncorrectable Error */
모모모모모모모모모모return -1;
모모모모모모모모}
모모모모모모}
모모모모}

모모모모/* Should never happen */
모모모모return -1;
모모}